import logging
# –ü—Ä–∏ –¥–µ–ø–ª–æ–µ —Ä–∞—Å–∫–æ–º–µ–Ω—Ç–∏—Ç—å
# logging.getLogger('aiogram').propagate = False # –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ aiogram –¥–æ –µ–≥–æ –∏–º–ø–æ—Ä—Ç–∞
# logging.basicConfig(level=logging.INFO, filename='log/app.log', filemode='a', format='%(levelname)s - %(asctime)s - %(name)s - %(message)s',) # –ü—Ä–∏ –¥–µ–ø–ª–æ–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ —Ñ–∞–π–ª
from worker_db import get_user_by_id, adding_user, adding_session, update_user
from functions import is_int_or_float, day_utcnow
from exchange import get_exchange
from category import get_category
from keys import telegram
import sys
import os
import asyncio
from pathlib import Path
from aiogram import Bot, Dispatcher, types, F, Router, html
from aiogram.enums import ParseMode
from aiogram.utils.markdown import hbold
from aiogram.filters import CommandStart, Command, Filter
from aiogram.types import (Message, BotCommand, LabeledPrice, ContentType,
                            InputFile, Document, PhotoSize, ReplyKeyboardRemove, 
                            InlineKeyboardMarkup, InlineKeyboardButton)
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import State, StatesGroup
from aiogram.client.default import DefaultBotProperties
# from WalletPay import AsyncWalletPayAPI
# from WalletPay import WalletPayAPI, WebhookManager
# from WalletPay.types import Event
# import uuid
from aiogram.utils.chat_action import ChatActionMiddleware




dp = Dispatcher() # All handlers should be attached to the Router (or Dispatcher)
#bot = Bot(telegram) #, default=types.DefaultBotProperties(parse_mode="Markdown")) # Initialize Bot instance with a default parse mode which will be passed to all API calls
bot = Bot(token=telegram, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
# router = Router()
# router.message.middleware(ChatActionMiddleware())
                                                                                                

# Get User_ID
def user_id(action) -> int:
    return action.from_user.id

# Show Typing
async def typing(action) -> None:
    await bot.send_chat_action(action.chat.id, action='typing')
    return




# PUSH /START
@dp.message(CommandStart())
async def command_start_handler(message: types.Message) -> None:
    await typing(message)

    await message.answer(f"RU\n–ü—Ä–∏–≤–µ—Ç, {html.bold(message.from_user.full_name)}!\n\n\
    üëõ –≠—Ç–æ –±–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–≥–∞–µ—Ç –≤–µ—Å—Ç–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–æ—Ö–æ–¥–æ–≤ –∏ —Ä–∞—Å—Ö–æ–¥–æ–≤ –∏–∑ —Ä–∞–∑–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤. –ü–æ–∑–≤–æ–ª—è–µ—Ç\
    –¥–æ—Ç–æ—à–Ω–æ –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Ä–∞—Å—Ö–æ–¥–æ–≤ –∏ –¥–æ—Ö–æ–¥–æ–≤, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—è —É–¥–æ–±–Ω—ã–π –æ—Ç—á–µ—Ç.\n\
    –î–ª—è –∫–∞–∫–æ–π —Ç–æ —á–∞—Å—Ç–∏ –ª—é–¥–µ–π - —ç—Ç–æ –æ—á–µ–Ω—å –ø–æ–ª–µ–∑–Ω–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä –¥–ª—è –º–µ–Ω—è.\n\n\
    üóë –ü—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏, –≤—ã –º–æ–∂–µ—Ç–µ —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è—Ö –≤ –±–∞–∑–µ, –Ω–∞–∂–∞—Ç–∏–µ–º –æ–¥–Ω–æ–π –∫–Ω–æ–ø–∫–∏. –ü–æ–¥—Ä–æ–±–Ω–µ–µ - –ø–æ–∑–∂–µ.\n\n\n\
EN\nHi, {html.bold(message.from_user.full_name)}!\n\n\
    üëõ This is a bot that helps to keep statistics on income and expenses from various sources. Allows\
    meticulously analyze the categories of expenses and income, providing a convenient report.\n\
    For some part of people, it is very useful, for example, for me.\n\n\
    üóë If desired, you can delete all transaction data in the database by pressing one button. More details later.")
        # Preparing user data
    id = user_id(message)
    name = message.from_user.username
    full_name = message.from_user.full_name
    first_name = message.from_user.first_name
    last_name = message.from_user.last_name
    date = await day_utcnow()
        # Save user data
    get_user = await get_user_by_id(id)
    if get_user is None:
        push_data_user = {
            "id": id,
            "name": name,
            "full_name": full_name,
            "first_name": first_name,
            "last_name": last_name,
            "date": date
        }
        await adding_user(push_data_user)
    else:
        print()
        logging.info(f"The user id:{id} is already in the database.")


    # MENU
    bot_commands = [
        BotCommand(command="/add", description="üìà –ü—Ä–∏—Ö–æ–¥"),
        BotCommand(command="/del", description="üìâ –†–∞—Å—Ö–æ–¥"),
        BotCommand(command="/mov", description="üí∏ –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ"), 
        BotCommand(command="/stat", description="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
        BotCommand(command="/set", description="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏"),
    ]
    await bot.set_my_commands(bot_commands)
    return










# SUB-MENU

class Form(StatesGroup):
        # Add
    add_cash = State() 
    add_cash_text = State() 
    add_cards = State()
    add_cards_text = State()
    add_crypto = State()
    add_crypto_text = State()
        # Dell
    del_cash = State()
    del_cash_text = State()
    del_cards = State()
    del_cards_text = State()
    del_crypto = State()
    del_crypto_text = State()
        # Move 
    mov_cash = State()
    mov_cash_choice = State()
    mov_card = State()
    mov_card_choice = State()
    mov_crypto = State()
    mov_crypto_choice = State()





######## ADD MONEY ########
@dp.message(Command("add"))
async def menu_add(message: types.Message):
        # Data preparation
    id = user_id(message)
    n = await get_user_by_id(id)
    if n:
        cash = n.cash
        crypto = n.crypto
        money_currency = n.money_currency
        crypto_currency = n.crypto_currency
        cards = n.cards

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=f"üíµ –ù–∞–ª–∏—á–Ω–æ—Å—Ç—å ({round(cash, 3)} {money_currency})", callback_data="add_cash")],
            [InlineKeyboardButton(text=f"üí≥ –ë–∞–Ω–∫–æ–≤—Å–∫–∏–µ –∫–∞—Ä—Ç—ã ({round(cards, 3)} {money_currency})", callback_data="add_cards")],
            [InlineKeyboardButton(text=f"üé´ –ö—Ä–∏–ø—Ç–∞ ({round(crypto, 3)} {crypto_currency}) ", callback_data="add_crypto")], 
        ]
    )
    await message.answer("üìà –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ –∫—É–¥–∞ –¥–æ–±–∞–≤–ª—è–µ—Ç–µ –¥–µ–Ω—å–≥–∏", reply_markup=keyboard)







# ADD MONEY CASH --- 1
@dp.callback_query(lambda c: c.data == 'add_cash')
async def process_add_cash(callback_query: types.CallbackQuery, state: FSMContext):
    await bot.send_message(callback_query.from_user.id, "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–∞–ª–∏—á–Ω–æ—Å—Ç–∏:")
    await bot.answer_callback_query(callback_query.id)
    await state.set_state(Form.add_cash)

# ADD MONEY CASH --- 2
@dp.message(Form.add_cash, F.content_type.in_({'text'}))
async def invoice_add_cash(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—é:")
        # Data preparation
    amount = await is_int_or_float(message.text)
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º  –¥–∞–Ω–Ω—ã–µ –≤ state
    await state.update_data(amount=amount)
    await state.set_state(Form.add_cash_text)

# ADD MONEY CASH --- 3
@dp.message(Form.add_cash_text, F.content_type.in_({'text'}))
async def invoice_add_cash_text(message: Message, state: FSMContext):
    id = user_id(message)
    text = message.text
    category = await get_category(text)
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')

    flow = "+"
    is_cash = True
    date = await day_utcnow()

        # –°heck in
    if amount is None:
        await message.answer("–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏")
        return

        # Saving a shared account User
    data_user = await get_user_by_id(id)
    if data_user is None:
        await message.answer("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ —Å /start")
        return
    all_cash = data_user.cash + amount
    money_currency = data_user.money_currency
    push_data_user = {
        "cash": round(all_cash, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is True:
        await message.answer(f"–î–æ–±–∞–≤–ª–µ–Ω–æ {amount} {money_currency}. –≤ –Ω–∞–ª–∏—á–Ω–æ—Å—Ç—å, –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è - '{category}'")
    else:
        await message.answer("–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")

        # Save Session
    push_data_session = {
        "category": category,
        "flow": flow,
        "is_cash": is_cash,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)

    await state.clear()











# ADD MONEY CARD --- 1
@dp.callback_query(lambda c: c.data == 'add_cards')
async def process_add_cards(callback_query: types.CallbackQuery, state: FSMContext):
    await bot.send_message(callback_query.from_user.id, "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–Ω–∫–æ–≤—Å–∫–æ–π –∫–∞—Ä—Ç—ã:")
    await bot.answer_callback_query(callback_query.id)
    await state.set_state(Form.add_cards)

# ADD MONEY CARD --- 2
@dp.message(Form.add_cards, F.content_type.in_({'text'}))
async def invoice_add_cards(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—é:")
        # Data preparation
    amount = await is_int_or_float(message.text)
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º  –¥–∞–Ω–Ω—ã–µ –≤ state
    await state.update_data(amount=amount)
    await state.set_state(Form.add_cards_text)

# ADD MONEY CARD --- 3
@dp.message(Form.add_cards_text, F.content_type.in_({'text'}))
async def invoice_add_cards_text(message: Message, state: FSMContext):
    id = user_id(message)
    text = message.text
    category = await get_category(text)
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')

    flow = "+"
    is_cards = True
    date = await day_utcnow()

        # –°heck in
    if amount is None:
        await message.answer("–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏")
        return

        # Saving a shared account User
    data_user = await get_user_by_id(id)
    if data_user is None:
        await message.answer("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ —Å /start")
        return
    all_cards = data_user.cards + amount
    money_currency = data_user.money_currency
    push_data_user = {
        "cards": round(all_cards, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is True:
        await message.answer(f"–î–æ–±–∞–≤–ª–µ–Ω–æ {amount} {money_currency} –Ω–∞ –∫–∞—Ä—Ç—ã, –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è - '{category}'")
    else:
        await message.answer("–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")

        # Save Session
    push_data_session = {
        "category": category,
        "flow": flow,
        "is_cards": is_cards,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)

    await state.clear()











# ADD MONEY CRYPTO --- 1
@dp.callback_query(lambda c: c.data == 'add_crypto')
async def process_add_crypto(callback_query: types.CallbackQuery, state: FSMContext):
    await bot.send_message(callback_query.from_user.id, "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –∫—Ä–∏–ø—Ç—ã:")
    await bot.answer_callback_query(callback_query.id)
    await state.set_state(Form.add_crypto)

# ADD MONEY CRYPTO --- 2
@dp.message(Form.add_crypto, F.content_type.in_({'text'}))
async def invoice_add_crypto(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—é:")
        # Data preparation
    amount = await is_int_or_float(message.text)
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º  –¥–∞–Ω–Ω—ã–µ –≤ state
    await state.update_data(amount=amount)
    await state.set_state(Form.add_crypto_text)

# ADD MONEY CRYPTO --- 3
@dp.message(Form.add_crypto_text, F.content_type.in_({'text'}))
async def invoice_add_crypto_text(message: Message, state: FSMContext):
    id = user_id(message)
    text = message.text
    category = await get_category(text)
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')

    flow = "+"
    is_crypto = True
    date = await day_utcnow()

        # –°heck in
    if amount is None:
        await message.answer("–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏")
        return

        # Saving a shared account User
    data_user = await get_user_by_id(id)
    if data_user is None:
        await message.answer("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ —Å /start")
        return
    all_crypto = data_user.crypto + amount
    crypto_currency = data_user.crypto_currency
    push_data_user = {
        "crypto": round(all_crypto, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is True:
        await message.answer(f"–î–æ–±–∞–≤–ª–µ–Ω–æ {amount} {crypto_currency} –≤ –∫—Ä–∏–ø—Ç—É, –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è - '{category}'")
    else:
        await message.answer("–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")

        # Save Session
    push_data_session = {
        "category": category,
        "flow": flow,
        "is_crypto": is_crypto,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)

    await state.clear()








######## DEL MONEY ########

@dp.message(Command("del"))
async def menu_del(message: types.Message):
        # Data preparation
    id = user_id(message)
    n = await get_user_by_id(id)
    if n:
        cash = n.cash
        crypto = n.crypto
        money_currency = n.money_currency
        crypto_currency = n.crypto_currency
        cards = n.cards

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=f"üíµ –ù–∞–ª–∏—á–Ω–æ—Å—Ç—å ({round(cash, 3)} {money_currency})", callback_data="del_cash")],
            [InlineKeyboardButton(text=f"üí≥ –ë–∞–Ω–∫–æ–≤—Å–∫–∏–µ –∫–∞—Ä—Ç—ã ({round(cards, 3)} {money_currency})", callback_data="del_cards")],
            [InlineKeyboardButton(text=f"üé´ –ö—Ä–∏–ø—Ç–∞ ({round(crypto, 3)} {crypto_currency}) ", callback_data="del_crypto")], # ü™™üßæüì∞
        ]
    )
    await message.answer("üìâ –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ —Ä–∞—Å—Ö–æ–¥–∞", reply_markup=keyboard)









# DEL MONEY CASH --- 1
@dp.callback_query(lambda c: c.data == 'del_cash')
async def process_del_cash(callback_query: types.CallbackQuery, state: FSMContext):
    await bot.send_message(callback_query.from_user.id, "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ä–∞—Å—Ö–æ–¥–∞ –Ω–∞–ª–∏—á–Ω–æ—Å—Ç–∏:")
    await bot.answer_callback_query(callback_query.id)
    await state.set_state(Form.del_cash)

# DEL MONEY CASH --- 2
@dp.message(Form.del_cash, F.content_type.in_({'text'}))
async def invoice_del_cash(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —Ä–∞—Å—Ö–æ–¥—É:")
        # Data preparation
    amount = await is_int_or_float(message.text)
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º  –¥–∞–Ω–Ω—ã–µ –≤ state
    await state.update_data(amount=amount)
    await state.set_state(Form.del_cash_text)

# DEL MONEY CASH --- 3
@dp.message(Form.del_cash_text, F.content_type.in_({'text'}))
async def invoice_del_cash_text(message: Message, state: FSMContext):
    id = user_id(message)
    text = message.text
    category = await get_category(text)
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')

    flow = "-"
    is_cash = True
    date = await day_utcnow()

        # –°heck in
    if amount is None:
        await message.answer("–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏")
        return

        # Saving a shared account User
    data_user = await get_user_by_id(id)
    if data_user is None:
        await message.answer("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ —Å /start")
        return
    all_cash = data_user.cash - amount
    money_currency = data_user.money_currency
    push_data_user = {
        "cash": round(all_cash, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is True:
        await message.answer(f"–ü–æ—Ç—Ä–∞—á–µ–Ω–æ {amount} {money_currency}. –∏–∑ –Ω–∞–ª–∏—á–Ω–æ—Å—Ç–∏, –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è —Ä–∞—Å—Ö–æ–¥–∞ - '{category}'")
    else:
        await message.answer("–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")

        # Save Session
    push_data_session = {
        "category": category,
        "flow": flow,
        "is_cash": is_cash,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)

    await state.clear()









# DEL MONEY CARD --- 1
@dp.callback_query(lambda c: c.data == 'del_cards')
async def process_del_cards(callback_query: types.CallbackQuery, state: FSMContext):
    await bot.send_message(callback_query.from_user.id, "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ä–∞—Å—Ö–æ–¥–∞ —Å –±–∞–Ω–∫–æ–≤—Å–∫–æ–π –∫–∞—Ä—Ç—ã:")
    await bot.answer_callback_query(callback_query.id)
    await state.set_state(Form.del_cards)

# DEL MONEY CARD --- 2
@dp.message(Form.del_cards, F.content_type.in_({'text'}))
async def invoice_del_cards(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —Ä–∞—Å—Ö–æ–¥—É:")
        # Data preparation
    amount = await is_int_or_float(message.text)
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º  –¥–∞–Ω–Ω—ã–µ –≤ state
    await state.update_data(amount=amount)
    await state.set_state(Form.del_cards_text)

# DEL MONEY CARD --- 3
@dp.message(Form.del_cards_text, F.content_type.in_({'text'}))
async def invoice_add_cards_text(message: Message, state: FSMContext):
    id = user_id(message)
    text = message.text
    category = await get_category(text)
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')

    flow = "-"
    is_cards = True
    date = await day_utcnow()

        # –°heck in
    if amount is None:
        await message.answer("–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏")
        return

        # Saving a shared account User
    data_user = await get_user_by_id(id)
    if data_user is None:
        await message.answer("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ —Å /start")
        return
    all_cards = data_user.cards - amount
    money_currency = data_user.money_currency
    push_data_user = {
        "cards": round(all_cards, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is True:
        await message.answer(f"–ü–æ—Ç—Ä–∞—á–µ–Ω–æ {amount} {money_currency} —Å –∫–∞—Ä—Ç—ã, –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è - '{category}'")
    else:
        await message.answer("–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")

        # Save Session
    push_data_session = {
        "category": category,
        "flow": flow,
        "is_cards": is_cards,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)

    await state.clear()











# DEL MONEY CRYPTO --- 1
@dp.callback_query(lambda c: c.data == 'del_crypto')
async def process_del_crypto(callback_query: types.CallbackQuery, state: FSMContext):
    await bot.send_message(callback_query.from_user.id, "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Å–Ω—è—Ç–∏—è —Å –∫—Ä–∏–ø—Ç—ã:")
    await bot.answer_callback_query(callback_query.id)
    await state.set_state(Form.del_crypto)

# DEL MONEY CRYPTO --- 2
@dp.message(Form.del_crypto, F.content_type.in_({'text'}))
async def invoice_del_crypto(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —Å–Ω—è—Ç–∏—é:")
        # Data preparation
    amount = await is_int_or_float(message.text)
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º  –¥–∞–Ω–Ω—ã–µ –≤ state
    await state.update_data(amount=amount)
    await state.set_state(Form.del_crypto_text)

# DEL MONEY CRYPTO --- 3
@dp.message(Form.del_crypto_text, F.content_type.in_({'text'}))
async def invoice_del_crypto_text(message: Message, state: FSMContext):
    id = user_id(message)
    text = message.text
    category = await get_category(text)
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')

    flow = "-"
    is_crypto = True
    date = await day_utcnow()

        # –°heck in
    if amount is None:
        await message.answer("–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏")
        return

        # Saving a shared account User
    data_user = await get_user_by_id(id)
    if data_user is None:
        await message.answer("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ —Å /start")
        return
    all_crypto = data_user.crypto - amount
    crypto_currency = data_user.crypto_currency
    push_data_user = {
        "crypto": round(all_crypto, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is True:
        await message.answer(f"–°–Ω—è—Ç–æ {amount} {crypto_currency} —Å –∫—Ä–∏–ø—Ç—ã, –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è - '{category}'")
    else:
        await message.answer("–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")

        # Save Session
    push_data_session = {
        "category": category,
        "flow": flow,
        "is_crypto": is_crypto,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)

    await state.clear()





######### MOVING #############

@dp.message(Command("mov"))
async def menu_del(message: types.Message):
        # Data preparation
    id = user_id(message)
    n = await get_user_by_id(id)
    if n:
        cash = n.cash
        crypto = n.crypto
        money_currency = n.money_currency
        crypto_currency = n.crypto_currency
        cards = n.cards

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=f"üíµ –ù–∞–ª–∏—á–Ω–æ—Å—Ç—å ({round(cash, 3)} {money_currency})", callback_data="mov_cash")],
            [InlineKeyboardButton(text=f"üí≥ –ë–∞–Ω–∫–æ–≤—Å–∫–∏–µ –∫–∞—Ä—Ç—ã ({round(cards, 3)} {money_currency})", callback_data="mov_cards")],
            [InlineKeyboardButton(text=f"üé´ –ö—Ä–∏–ø—Ç–∞ ({round(crypto, 3)} {crypto_currency}) ", callback_data="mov_crypto")], # ü™™üßæüì∞
        ]
    )
    await message.answer("üìâ –û—Ç–∫—É–¥–∞ –±—É–¥–µ–º –ø–µ—Ä–µ–º–µ—â–∞—Ç—å –¥–µ–Ω—å–≥–∏:", reply_markup=keyboard)




# MOVING MONEY CASH TO CARD OR TO CRYPTO--- 1
@dp.callback_query(lambda c: c.data == 'mov_cash')
async def process_mov_cash(callback_query: types.CallbackQuery, state: FSMContext):
    await bot.send_message(callback_query.from_user.id, "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–µ—Ä–µ–º–µ—â–∞–µ–º—É—é –∏–∑ –Ω–∞–ª–∏—á–Ω–æ—Å—Ç–∏:")
    await bot.answer_callback_query(callback_query.id)
    await state.set_state(Form.mov_cash)

# MOVING MONEY CASH --- 2
@dp.message(Form.mov_cash)
async def invoice_mov_cash(message: Message, state: FSMContext):
    id = user_id(message)
        # Data preparation
    amount = await is_int_or_float(message.text)
        # –°heck in
    if amount is None:
        await message.answer("–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏")
        return
        # –°heck cash
    data_user = await get_user_by_id(id)
    if data_user is None:
        await message.answer("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ —Å /start")
        return
    cash = data_user.cash
    if cash < amount:
        await message.answer("–û—à–∏–±–∫–∞: –£ –≤–∞—Å –Ω–µ—Ç —Å—Ç–æ–ª—å–∫–æ –Ω–∞–ª–∏—á–∫–∏, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å—É–º–º—É –º–µ–Ω—å—à–µ")
        return
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º  –¥–∞–Ω–Ω—ã–µ –≤ state
    await state.update_data(amount=amount)
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üí≥ –ù–∞ –∫–∞—Ä—Ç—É", callback_data="cash_to_card")], 
            [InlineKeyboardButton(text="üé´ –í –∫—Ä–∏–ø—Ç—É", callback_data="cash_to_crypto")],

        ]
    )
    await bot.send_message(message.chat.id, f"–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ –∫—É–¥–∞ –ø–µ—Ä–µ–º–µ—â–∞–µ–º (RUB):", reply_markup=keyboard)
    await state.set_state(Form.mov_cash_choice)


# MOVING MONEY CASH TO CARD --- 3
@dp.callback_query(Form.mov_cash_choice, lambda c: c.data == 'cash_to_card')
async def process_mov_cash_to_card(callback_query: types.CallbackQuery, state: FSMContext):
    id = callback_query.from_user.id
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')
    data_user = await get_user_by_id(id)
    new_cash = data_user.cash - amount
    new_cards = data_user.cards + amount
    push_data_user = {
        "cash": round(new_cash, 3),
        "cards": round(new_cards, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is False:
        await bot.send_message(callback_query.from_user.id, "–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")
        # Save cash
    flow = "-"
    is_cash = True
    date = await day_utcnow()
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_cash": is_cash,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Save card
    flow = "+"
    is_cards = True
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_cards": is_cards,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Message
    await bot.send_message(callback_query.from_user.id, "–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
    await bot.answer_callback_query(callback_query.id)
    await state.clear()


# MOVING MONEY CASH TO CRYPTO --- 3
@dp.callback_query(Form.mov_cash_choice, lambda c: c.data == 'cash_to_crypto')
async def process_mov_cash_to_crypto(callback_query: types.CallbackQuery, state: FSMContext):
    id = callback_query.from_user.id
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')
    data_user = await get_user_by_id(id)

    one_usd = await get_exchange()
    if one_usd is None:
        one_usd = 100
        logging.error(f"Failed get exchange")
    new_cash = data_user.cash - amount
    new_crypto = data_user.crypto + amount / one_usd
    push_data_user = {
        "cash": round(new_cash, 3),
        "crypto": round(new_crypto, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is False:
        await bot.send_message(callback_query.from_user.id, "–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")
        # Save cash
    flow = "-"
    is_cash = True
    date = await day_utcnow()
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_cash": is_cash,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Save card
    flow = "+"
    is_crypto = True
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_crypto": is_crypto,
        "amount": round(amount / one_usd, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Message
    await bot.send_message(callback_query.from_user.id, "–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ. –í–æ–∑–º–æ–∂–Ω–æ, –≤–∞–º –ø—Ä–∏–¥–µ—Ç—Å—è —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏—Ö–æ–¥ —Å —É—á–µ—Ç–æ–º –∫–æ–º–∏—Å–∏–∏ –∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫—É—Ä—Å–∞ –≤ P2P. –ß—Ç–æ —É—á—Ç–µ—Ç—Å—è –≤–≤–∏–¥–µ —Ä–∞—Å—Ö–æ–¥–∞.")
    await bot.answer_callback_query(callback_query.id)
    await state.clear()












# MOVING MONEY CARD TO CASH OR TO CRYPTO--- 1
@dp.callback_query(lambda c: c.data == 'mov_cards')
async def process_mov_card(callback_query: types.CallbackQuery, state: FSMContext):
    await bot.send_message(callback_query.from_user.id, "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–µ—Ä–µ–º–µ—â–∞–µ–º—É—é —Å –∫–∞—Ä—Ç—ã:")
    await bot.answer_callback_query(callback_query.id)
    await state.set_state(Form.mov_card)

# MOVING MONEY CARD --- 2
@dp.message(Form.mov_card)
async def invoice_mov_card(message: Message, state: FSMContext):
    id = user_id(message)
        # Data preparation
    amount = await is_int_or_float(message.text)
        # –°heck in
    if amount is None:
        await message.answer("–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏")
        return
        # –°heck cash
    data_user = await get_user_by_id(id)
    if data_user is None:
        await message.answer("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ —Å /start")
        return
    cards = data_user.cards
    if cards < amount:
        await message.answer("–û—à–∏–±–∫–∞: –£ –≤–∞—Å –Ω–µ—Ç —Å—Ç–æ–ª—å–∫–æ –Ω–∞ –∫–∞—Ä—Ç–µ, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å—É–º–º—É –º–µ–Ω—å—à–µ")
        return
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º  –¥–∞–Ω–Ω—ã–µ –≤ state
    await state.update_data(amount=amount)
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üíµ –í –Ω–∞–ª–∏—á–∫—É", callback_data="card_to_cash")], 
            [InlineKeyboardButton(text="üé´ –í –∫—Ä–∏–ø—Ç—É", callback_data="card_to_crypto")],

        ]
    )
    await bot.send_message(message.chat.id, f"–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ –∫—É–¥–∞ –ø–µ—Ä–µ–º–µ—â–∞–µ–º (RUB):", reply_markup=keyboard)
    await state.set_state(Form.mov_card_choice)


# MOVING MONEY CASH TO CARD --- 3
@dp.callback_query(Form.mov_card_choice, lambda c: c.data == 'card_to_cash')
async def process_mov_card_to_cash(callback_query: types.CallbackQuery, state: FSMContext):
    id = callback_query.from_user.id
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')
    data_user = await get_user_by_id(id)
    new_cards = data_user.cards - amount
    new_cash = data_user.cash + amount
    push_data_user = {
        "cash": round(new_cash, 3),
        "cards": round(new_cards, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is False:
        await bot.send_message(callback_query.from_user.id, "–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")
        # Save cash
    flow = "-"
    is_cards = True
    date = await day_utcnow()
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_cards": is_cards,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Save card
    flow = "+"
    is_cash = True
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_cash": is_cash,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Message
    await bot.send_message(callback_query.from_user.id, "–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
    await bot.answer_callback_query(callback_query.id)
    await state.clear()


# MOVING MONEY CASH TO CRYPTO --- 3
@dp.callback_query(Form.mov_card_choice, lambda c: c.data == 'card_to_crypto')
async def process_mov_card_to_crypto(callback_query: types.CallbackQuery, state: FSMContext):
    id = callback_query.from_user.id
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')
    data_user = await get_user_by_id(id)

    one_usd = await get_exchange()
    if one_usd is None:
        one_usd = 100
        logging.error(f"Failed get exchange")
    new_cards = data_user.cards - amount
    new_crypto = data_user.crypto + amount / one_usd
    push_data_user = {
        "cards": round(new_cards, 3),
        "crypto": round(new_crypto, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is False:
        await bot.send_message(callback_query.from_user.id, "–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")
        # Save cash
    flow = "-"
    is_cards = True
    date = await day_utcnow()
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_cards": is_cards,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Save card
    flow = "+"
    is_crypto = True
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_crypto": is_crypto,
        "amount": round(amount / one_usd, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Message
    await bot.send_message(callback_query.from_user.id, "–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ. –í–æ–∑–º–æ–∂–Ω–æ, –≤–∞–º –ø—Ä–∏–¥–µ—Ç—Å—è —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏—Ö–æ–¥ —Å —É—á–µ—Ç–æ–º –∫–æ–º–∏—Å–∏–∏ –∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫—É—Ä—Å–∞ –≤ P2P. –ß—Ç–æ —É—á—Ç–µ—Ç—Å—è –≤–≤–∏–¥–µ —Ä–∞—Å—Ö–æ–¥–∞.")
    await bot.answer_callback_query(callback_query.id)
    await state.clear()















# MOVING MONEY CRYPTO TO CASH OR TO CARDS--- 1
@dp.callback_query(lambda c: c.data == 'mov_crypto')
async def process_mov_crypto(callback_query: types.CallbackQuery, state: FSMContext):
    await bot.send_message(callback_query.from_user.id, "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–µ—Ä–µ–º–µ—â–∞–µ–º—É—é —Å –∫—Ä–∏–ø—Ç—ã:")
    await bot.answer_callback_query(callback_query.id)
    await state.set_state(Form.mov_crypto)

# MOVING MONEY CACRYPTORD --- 2
@dp.message(Form.mov_crypto)
async def invoice_mov_crypto(message: Message, state: FSMContext):
    id = user_id(message)
        # Data preparation
    amount = await is_int_or_float(message.text)
        # –°heck in
    if amount is None:
        await message.answer("–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏")
        return
        # –°heck cash
    data_user = await get_user_by_id(id)
    if data_user is None:
        await message.answer("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ —Å /start")
        return
    crypto = data_user.crypto
    if crypto < amount:
        await message.answer("–û—à–∏–±–∫–∞: –£ –≤–∞—Å –Ω–µ—Ç —Å—Ç–æ–ª—å–∫–æ –≤ –∫—Ä–∏–ø—Ç–µ, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å—É–º–º—É –º–µ–Ω—å—à–µ")
        return
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º  –¥–∞–Ω–Ω—ã–µ –≤ state
    await state.update_data(amount=amount)
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üíµ –í –Ω–∞–ª–∏—á–∫—É", callback_data="crypto_to_cash")], 
            [InlineKeyboardButton(text="üí≥ –ù–∞ –∫—É—Ä—Ç—É", callback_data="crypto_to_cards")],

        ]
    )
    await bot.send_message(message.chat.id, f"–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ –∫—É–¥–∞ –ø–µ—Ä–µ–º–µ—â–∞–µ–º (USD):", reply_markup=keyboard)
    await state.set_state(Form.mov_crypto_choice)


# MOVING MONEY CRYPTO TO CASH --- 3
@dp.callback_query(Form.mov_crypto_choice, lambda c: c.data == 'crypto_to_cash')
async def process_mov_crypto_to_cash(callback_query: types.CallbackQuery, state: FSMContext):
    id = callback_query.from_user.id
    one_usd = await get_exchange()
    if one_usd is None:
        one_usd = 100
        logging.error(f"Failed get exchange")
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')
    data_user = await get_user_by_id(id)
    new_crypto = data_user.crypto - amount
    new_cash = data_user.cash + amount * one_usd
    push_data_user = {
        "cash": round(new_cash, 3),
        "crypto": round(new_crypto, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is False:
        await bot.send_message(callback_query.from_user.id, "–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")
        # Save cash
    flow = "-"
    is_crypto = True
    date = await day_utcnow()
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_crypto": is_crypto,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Save card
    flow = "+"
    is_cash = True
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_cash": is_cash,
        "amount": round(amount * one_usd, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Message
    await bot.send_message(callback_query.from_user.id, "–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
    await bot.answer_callback_query(callback_query.id)
    await state.clear()


# MOVING MONEY CRYPTO TO CARDS --- 3
@dp.callback_query(Form.mov_crypto_choice, lambda c: c.data == 'crypto_to_cards')
async def process_mov_card_to_crypto(callback_query: types.CallbackQuery, state: FSMContext):
    id = callback_query.from_user.id
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    amount = data.get('amount')
    data_user = await get_user_by_id(id)

    one_usd = await get_exchange()
    if one_usd is None:
        one_usd = 100
        logging.error(f"Failed get exchange")
    new_crypto = data_user.crypto - amount
    new_cards = data_user.cards + amount * one_usd
    push_data_user = {
        "crypto": round(new_crypto, 3),
        "cards": round(new_cards, 3),
    }
    confirm_user = await update_user(id, push_data_user)
    if confirm_user is False:
        await bot.send_message(callback_query.from_user.id, "–û—à–∏–±–∫–∞ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑—É.")
        # Save cash
    flow = "-"
    is_crypto = True
    date = await day_utcnow()
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_crypto": is_crypto,
        "amount": round(amount, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Save card
    flow = "+"
    is_cards = True
        # Save Session
    push_data_session = {
        "category": "moving",
        "flow": flow,
        "is_cards": is_cards,
        "amount": round(amount * one_usd, 3),
        "users_id": id,
        "date": date
    }
    await adding_session(push_data_session)
        # Message
    await bot.send_message(callback_query.from_user.id, "–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ. –í–æ–∑–º–æ–∂–Ω–æ, –≤–∞–º –ø—Ä–∏–¥–µ—Ç—Å—è —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏—Ö–æ–¥ —Å —É—á–µ—Ç–æ–º –∫–æ–º–∏—Å–∏–∏ –∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫—É—Ä—Å–∞ –≤ P2P. –ß—Ç–æ —É—á—Ç–µ—Ç—Å—è –≤–≤–∏–¥–µ —Ä–∞—Å—Ö–æ–¥–∞.")
    await bot.answer_callback_query(callback_query.id)
    await state.clear()
















































######## Statistic ########
@dp.message(Command("stat"))
async def menu_stat(message: types.Message):
    #id = user_id(message)
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –º–µ—Å—è—Ü", callback_data="stat_month")],
            [InlineKeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –≥–æ–¥", callback_data="stat_year")],
            # [InlineKeyboardButton(text="üìä ", callback_data="add_crypto")],
        ]
    )
    await message.answer("üìä –í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:", reply_markup=keyboard)

# STAT --- month
@dp.callback_query(lambda c: c.data == 'stat_month')
async def process_stat_month(callback_query: types.CallbackQuery):
    await bot.send_message(callback_query.from_user.id, "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –º–µ—Å—è—Ü")
    await bot.answer_callback_query(callback_query.id)

# STAT --- year
@dp.callback_query(lambda c: c.data == 'stat_year')
async def process_stat_year(callback_query: types.CallbackQuery):
    await bot.send_message(callback_query.from_user.id, "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –≥–æ–¥")
    await bot.answer_callback_query(callback_query.id)



######## SETINGS ########
@dp.message(Command("set"))
async def menu_stat(message: types.Message):
    #id = user_id(message)
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="–í–∞–ª—é—Ç–∞", callback_data="currency")],
            [InlineKeyboardButton(text="–Ø–∑—ã–∫ –±–æ—Ç–∞", callback_data="lang")],
            # [InlineKeyboardButton(text="Backup", callback_data="backup")],
        ]
    )
    await message.answer("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏:", reply_markup=keyboard)

# SET --- currency
@dp.callback_query(lambda c: c.data == 'currency')
async def process_currency(callback_query: types.CallbackQuery):
    await bot.send_message(callback_query.from_user.id, "currency")
    await bot.answer_callback_query(callback_query.id)

# SET --- lang
@dp.callback_query(lambda c: c.data == 'lang')
async def process_lang(callback_query: types.CallbackQuery):
    await bot.send_message(callback_query.from_user.id, "lang")
    await bot.answer_callback_query(callback_query.id)



#                                                                           #
############################# SUB-MENU ######################################








@dp.message()
async def my_handler(message: Message):
    await typing(message)
    await asyncio.sleep(2)
    result = message.text
    print(result)
    await message.answer(result)



# @router.message()
# async def echo_handler(message: Message) -> None:
#     try:
#         # Send a copy of the received message
#         await message.send_copy(chat_id=message.chat.id)
#     except TypeError:
#         # But not all the types is supported to be copied so need to handle it
#         await message.answer("Nice try!")







if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, stream=sys.stdout) # –ü—Ä–∏ –¥–µ–ø–ª–æ–µ –∑–∞–∫–æ–º–µ–Ω—Ç–∏—Ç—å
    asyncio.run(dp.start_polling(bot, skip_updates=False)) # skip_updates=False –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –∫–∞–∂–¥–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–≤ Telegram, –≤–∞–∂–Ω–æ –¥–ª—è –ø—Ä–∏–Ω—è—Ç–∏—è –ø–ª–∞—Ç–µ–∂–µ–π
































# async def main() -> None:
#     # Initialize Bot instance with default bot properties which will be passed to all API calls
#     bot = Bot(token=telegram, default=DefaultBotProperties(parse_mode=ParseMode.HTML)) # Markdown  HTML
#     # And the run events dispatching
#     await dp.start_polling(bot)


# if __name__ == "__main__":
#     logging.basicConfig(level=logging.INFO, stream=sys.stdout)
#     asyncio.run(main())